from django.db import models

from core.logging import get_logger
from integrations.braintree.client import get_braintree_gateway
from .base import BaseModel, TimestampModel

logger = get_logger(__name__)


class AddressModel(TimestampModel):

    company = models.CharField(
        max_length=128,
        blank=True,
        null=True,
        help_text="Company name.",
    )

    first_name = models.CharField(
        max_length=128,
        blank=True,
        null=True,
        help_text="First name.",
    )

    last_name = models.CharField(
        max_length=128,
        blank=True,
        null=True,
        help_text="Last name.",
    )

    class Meta(TimestampModel.Meta):
        abstract = True


class CustomerManager(models.Manager):
    def update_or_create_from_remote_object(self, remote_obj):
        obj, created = self.model.objects.update_or_create(
            id=remote_obj.id,
            defaults=self.model.get_default_fields(remote_obj),
        )

        for bt_creditcard in remote_obj.credit_cards:
            obj.payment_methods.update_or_create_from_remote_object(bt_creditcard)

        # TODO: memoize credit card addresses for efficiency
        for bt_address in remote_obj.addresses:
            obj.addresses.update_or_create_from_remote_object(bt_address)

        return obj, created

    def bulk_update_or_create_from_sync(self, *customer_ids):
        gateway = get_braintree_gateway()
        bt_customers = gateway.get_customers_by_id(*customer_ids)
        for remote_obj in bt_customers:
            try:
                customer, _ = self.update_or_create_from_remote_object(remote_obj)
            except Exception:
                logger.error(f"Could not sync {self.model} {remote_obj.id}")
        return customer, _

    def update_or_create_from_sync(self, customer_id):
        gateway = get_braintree_gateway()
        bt_customer = gateway.customer.find(customer_id)
        return self.update_or_create_from_remote_object(bt_customer)

    def get_or_sync(self, id):
        try:
            obj = self.get(id=id)
        except self.model.DoesNotExist:
            obj, _ = self.update_or_create_from_sync(id)
        return obj


class Customer(BaseModel, AddressModel):

    objects = CustomerManager()

    # addresses (below)

    # android_pay_cards (skipped)

    # apple_pay_cards (skipped)

    # company (address model)

    # created_at (timestamp model)

    # credit_cards (payment_methods)

    # custom_fields (skipped)

    email = models.EmailField(
        blank=True,
        null=True,
        help_text="Email address composed of ASCII characters.",
    )

    fax = models.CharField(
        max_length=30,
        blank=True,
        null=True,
        help_text="Fax number.",
    )

    # first_name (address model)

    # graphql_id

    # id (base model)

    # last_name (address model)

    # masterpass_cards (skipped)

    # payment_methods (skipped - would pass through concrete base)

    # paypal_accounts (skipped)

    phone = models.CharField(
        max_length=128,
        blank=True,
        null=True,
        help_text="Phone number.",
    )

    # samsung_pay_cards (skipped)

    # updated_at (timestamp model)

    # us_bank_accounts (skipped)

    # venmo_accounts (skipped)

    # visa_checkout_cards (skipped)

    website = models.URLField(
        blank=True,
        null=True,
        help_text="Website URL.",
    )


class AddressManager(models.Manager):
    def update_or_create_from_remote_object(self, remote_obj):
        customer_id = Customer.objects.get_or_sync(remote_obj.customer_id).id
        obj, created = self.model.objects.update_or_create(
            customer_id=customer_id,
            id=remote_obj.id,
            defaults=self.model.get_default_fields(remote_obj),
        )
        return obj, created


class Address(AddressModel):
    """Address customer, ID, and at least one field are mandatory.
    ID is auto-generated by Braintree if not provided and unique per customer.
    """

    DEFAULT_FIELDS_EXCLUDED = ("id", "address_id", "customer")

    objects = AddressManager()

    # need a different PK since customer not sufficiently unique
    address_id = models.AutoField(primary_key=True)

    # company (address model)

    # created_at (timestamp model)

    customer = models.ForeignKey(
        Customer,
        on_delete=models.CASCADE,
        related_name="addresses",
        help_text="Customer that owns this address.",
    )

    extended_address = models.CharField(
        max_length=128,
        blank=True,
        null=True,
        help_text="The extended address informationâ€”such as apartment or suite number.",
    )

    # first_name (address model)

    id = models.CharField(
        max_length=2,
        help_text="The two-letter value for an address associated with a specific customer ID. "
        "The maximum number of addresses per customer is 50.",
    )

    # last_name (address model)

    locality = models.CharField(
        max_length=128,
        blank=True,
        null=True,
        help_text="The locality/city.",
    )

    postal_code = models.CharField(
        max_length=128,
        blank=True,
        null=True,
        help_text="The postal code.",
    )

    region = models.CharField(
        max_length=128,
        blank=True,
        null=True,
        help_text="The state or province.",
    )

    street_address = models.CharField(
        max_length=256,
        blank=True,
        null=True,
        help_text="The street address.",
    )

    # updated_at (timestamp model)

    class Meta(AddressModel.Meta):
        constraints = [
            models.UniqueConstraint(fields=["customer_id", "id"], name="customer_address"),
        ]
